<html>
    <meta charset="utf-8" />
    <title>llama2.rs.wasm</title>
    <style>
        body {
            padding: 1em;
        }
        label,
        button {
            margin: 0.5em;
        }
        input {
            width: 5em;
        }
        textarea {
            padding: 1em;
        }
    </style>
    <head>
        <!-- preload loads ALOT of junk @todo, memory goes up fast -->
        <link rel="preload" href="/pkg_port1/port1_bg.wasm" as="fetch" type="application/wasm"/>
        <link rel="preload" href="/pkg_port2/port2_bg.wasm" as="fetch" type="application/wasm"/>
        <link rel="preload" href="/tokenizer_port1.bin" as="fetch" type="application/binary"/>
        <link rel="preload" href="/tokenizer_port2.bin" as="fetch" type="application/binary"/>

        <!--
        <link rel="preload" href="https://huggingface.co/karpathy/tinyllamas/resolve/main/stories42M.bin" as="fetch" type="application/binary"/>
        <link rel="preload" href="https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin" as="fetch" type="application/binary"/>
        <link rel="preload" href="https://huggingface.co/karpathy/tinyllamas/resolve/main/stories110M.bin" as="fetch" type="application/binary"/>
        -->
        
        <link rel="module" href="/pkg_port1/port1_bg.js" as="fetch" type="application/javascript"/> 
        <link rel="module" href="/pkg_port2/port2_bg.js" as="fetch" type="application/javascript"/>
        <script>
            const stories = { 
                stories15M : "https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin",
                stories42M : "https://huggingface.co/karpathy/tinyllamas/resolve/main/stories42M.bin",
                stories110M : "https://huggingface.co/karpathy/tinyllamas/resolve/main/stories110M.bin",
            };
            let runtimes = {};
  
            function append_to_output(msg,...args){
                document.getElementById("output").value = 
                document.getElementById("output").value +"\n"+ msg;
            }
 
            function onChangePort(port){
                document.getElementById("output").value = "";
                if(port && port=="port1"){
                    document.getElementById("prompt").disabled="disabled";
                    document.getElementById("prompt").value="not supported for this port";
                }else{
                    document.getElementById("prompt").disabled="";
                    document.getElementById("prompt").value="";
                }
            }
        </script>         
    </head>
    <body>
        <div>
            <div>
                <select id="whichport" onchange="onChangePort(this.value)">
                    <option value="port1" noprompt="true">@Gaxler's (port1)</option>
                    <option selected="selected" value="port2"> @leo-du's (port2)</option>
                </select>
            </div>

            <div>
                <textarea id="prompt" type="text" value="" cols="80" rows="1"></textarea>
            </div>
            <select id="model">
                <option value="stories15M">stories15m</option>
                <option selected="selected" value="stories42M">stories42m</option>
                <option value="stories110M">stories110m</option>
            </select>

            <label>temperature</label><input id="temperature" type="number" value="0.9" /> <label>Steps</label><input id="steps" type="number" value="20" />
            <button id="run">run</button>
        </div>
        <textarea id="output" rows="20" cols="80"></textarea>
        <p><span>achieved tok/s: </span><span id="toks"></span></p>
        <!-- Note the usage of `type=module` here as this is an ES6 module -->
        <script type="module" id="port1">
            // Use ES module import syntax to import functionality from the module
            // that we have compiled.
            //
            // Note that the `default` import is an initialization function which
            // will "boot" the module and make it ready to use. Currently browsers
            // don't support natively imported WebAssembly as an ES module, but
            // eventually the manual initialization won't be required!
            import init, {main_wasm, initThreadPool  } from './pkg_port1/port1.js';
            async function run_port1() {
                await init();
                if (navigator.hardwareConcurrency >0){
                    const cpus_in_use = Math.ceil(navigator.hardwareConcurrency*0.75);
                    //requires https://stackoverflow.com/questions/72881660/web-worker-blocked-by-self-crossoriginisolated-on-cypress
                    //Cross-Origin-Opener-Policy="same-origin"
                    //Cross-Origin-Resource-Policy="same-site"
                    //Cross-Origin-Embedder-Policy="require-corp"
                    //Fixme(https://github.com/mtb0x1/llama2.rs.wasm/issues/1)
                    //await initThreadPool(cpus_in_use);
                }
                document.getElementById("output").value ="";
                let model = stories[document.getElementById("model").value];
                const model_buffer =await fetch(model)
                .then(response => response.arrayBuffer())
                .then(buffer => {
                    // Convert the ArrayBuffer to a Uint8Array
                    return new Uint8Array(buffer);
                });
                append_to_output("JS: model_buffer fetched");

                const tokenizer_buffer =await fetch('tokenizer_port1.bin')
                .then(response => response.arrayBuffer())
                .then(buffer => {
                    // Convert the ArrayBuffer to a Uint8Array
                    return new Uint8Array(buffer);
                });
                append_to_output("JS: tokenizer_buffer fetched");
                
                let temperature  = document.getElementById("temperature").value;
                let steps = document.getElementById("steps").value;
                let prompt = document.getElementById("prompt").value?? ""; 

                let result = main_wasm(model_buffer,tokenizer_buffer,temperature,steps,/*not used*/prompt);
                append_to_output("JS: Result =["+result+"]"); // this one doesn't return a thing, yet ?
            }
            runtimes.port1 = run_port1;
            //document.getElementById('run').addEventListener('click', run_port1);

        </script>
        
        <script type="module" id="port2">
            // Use ES module import syntax to import functionality from the module
            // that we have compiled.
            //
            // Note that the `default` import is an initialization function which
            // will "boot" the module and make it ready to use. Currently browsers
            // don't support natively imported WebAssembly as an ES module, but
            // eventually the manual initialization won't be required!
            import init, {main_wasm, initThreadPool  } from './pkg_port2/port2.js';
            async function run_port2() {
                await init();
                if (navigator.hardwareConcurrency >0){
                    const cpus_in_use = Math.ceil(navigator.hardwareConcurrency*0.75);
                    //requires https://stackoverflow.com/questions/72881660/web-worker-blocked-by-self-crossoriginisolated-on-cypress
                    //Cross-Origin-Opener-Policy="same-origin"
                    //Cross-Origin-Resource-Policy="same-site"
                    //Cross-Origin-Embedder-Policy="require-corp"
                    //Fixme(https://github.com/mtb0x1/llama2.rs.wasm/issues/1)
                    //await initThreadPool(cpus_in_use);
                }
                document.getElementById("output").value ="";
                let model = stories[document.getElementById("model").value];
                const model_buffer =await fetch(model)
                .then(response => response.arrayBuffer())
                .then(buffer => {
                    // Convert the ArrayBuffer to a Uint8Array
                    return new Uint8Array(buffer);
                });
                append_to_output("JS: model_buffer fetched");
    
                const tokenizer_buffer =await fetch('tokenizer_port2.bin')
                .then(response => response.arrayBuffer())
                .then(buffer => {
                    // Convert the ArrayBuffer to a Uint8Array
                    return new Uint8Array(buffer);
                });
                append_to_output("JS: tokenizer_buffer fetched");
                
                let temperature  = document.getElementById("temperature").value;
                let steps = document.getElementById("steps").value;
                let prompt = document.getElementById("prompt").value?? ""; 
    
                let result = main_wasm(model_buffer,tokenizer_buffer,temperature,steps,prompt);
                append_to_output("JS: Result = ["+result+"]");
            }
            runtimes.port2 = run_port2;
            //document.getElementById('run').addEventListener('click', run_port2);
    
            </script>
            <script>
                function run(){
                    runtimes[document.getElementById("whichport").value]();
                }
                document.getElementById('run').addEventListener('click',run);
            </script>
            
    </body>
</html>
